///////////////////////////////////////////////
Debug::print -> rename to println and allow std::format_string input
also have different overloads, one with format_string, one without, etc.
///////////////////////////////////////////////

///////////////////////////////////////////////
Predefine SKey objects with default input device, button, etc. e.g.:

// very well could have these defined in json, and query that when loading so these
// aren't always loaded in-game
unordered_map<std::string, SKey> defaultKeys;

const SKey& getKey(const std::string& key)
{
    return defaultKeys[key];
}

// could have the keys just be static members of a class or something,
// and treat them like an enum, but then a manual string->key & key->string
// conversion stuff would be required, vs a map or json where the keys are mapped to strings

Example keys definition json:
{
    "keys": {
        "A": {
            "device": "keyboard",
            "code": "A",
            "scalar": false
        },
        "LeftTrigger": {
            "device": "controller",
            "code": "LeftTrigger",
            "scalar": true
        },
        "LeftMouseButton": {
            "device": "mouse",
            "code": "Left",
            "scalar": false
        }
    }
}

It takes a user-friendly name and maps to what should be default for that key (like unreal kinda).

Then, in C++:

void setupInput()
{
    string pathToJson;
    json keys {pathToJson};
    
    // get used keys
    // populate keys being used or something
    
    // close json, etc.
}

You get it.
///////////////////////////////////////////////

///////////////////////////////////////////////
Asset loading/mapping via plain json file

"assets.json"
{
    "textures": {
        "player": "player.png",
        "enemy": "enemy.png"
    },
    "sounds": {
        "jump": "jump.ogg"
    },
    "fonts": {
        "main": "arial.ttf"
    },
    "groups": {
        "player": {
            "textures": [ // when multiple required
                "player"
            ],
            "sounds": [
                "jump"
            ],
            "texture": "player" // when just one required
        }
    }
}

"level.json"
{
    "assets": {
        "textures": [
            "enemy"
        ]
        "groups": [
            "player"
        ]
    },
    "etc"
}

- CLevel loads level.json
- CLevel loads assets into data cache from level.json
- data cache combines path value from json with path dir from engine.ini
- data cache loads from file

The level won't have entity-specific assets to load, only level-specific ones.
Individual entities will have their own assets they depend on, gotten somehow.
Maybe a virtual function that returns a vector of strings (IDs)? Or just a vector of strings set in the constructor?
Possibly a feature of CObject, or another abstract class - IAssetContainer - or something
///////////////////////////////////////////////

///////////////////////////////////////////////
engine.json
{
    "render": {
        "resolution": {
            "x": 240,
            "y": 160
        },
        "resizable": false
    },
    "dirs": {
        "texture": "res/textures/",
        "sound": "res/sounds/",
        "music": "res/music/",
        "font": "res/fonts/"
    },
    "assets": {
        "texture": {
            "player": "player.png",
            "enemy": "enemy.png"
        },
        "sound": {
            "jump": "player_jump.ogg"
        },
        "groups": {
            "player": {
                "texture": [
                    "player"
                ],
                "sound": [
                    "jump"
                ]
            }
        }
    }
}
///////////////////////////////////////////////

Entity:
- Array of asset IDs

Level:
- Local asset cache
- With each entity spawned, load/get asset via value in engine.json found at entity's key

Asset Cache:
- Either base class or final class used with composition that just holds loaded assets

enum class EAssetCategory : uint
{
    Texture,
    Sound,
    Font
}

struct SAssetHandle
{
    string id;
    string path;
    EAssetCategory category;
}

class CAssetCache
{
    unordered_map<SAssetHandle, unique_ptr<IAssetResource>> m_assets;
}

class CLevel : CAssetCache
{
    void loadFromFile(string path)
    {
        for (auto& entity : m_entities)
        {
            for (auto& entityAsset : entity->getRequiredAssets())
            {
                loadAsset(entityAsset);
            }
        }
    }
}

getLevel().loadAsset(EAssetCategory::Texture, "player_sprite");
getLevel().getAssetCache().load(EAssetCategory::Texture, "player_sprite");

class Entity
{
    vector<string> m_requiredAssets;
}

// assets.json or something
{
    "assets": [
        {
            "id": "player_sprite",
            "path": "res/textures/player_sprite.png",
            "type": "texture"
        }
    ]
}
